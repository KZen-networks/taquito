#!/usr/bin/env node

const crypto = require('crypto');
const rp = require('request-promise');
const program = require('commander');
const fs = require('fs');
const path = require('path');
const low = require('lowdb');
const FileSync = require('lowdb/adapters/FileSync');

const { InMemorySigner, PublicOnlySigner } = require('../packages/taquito-signer/dist/lib');

const { Tezos } = require('../packages/taquito/dist/lib/taquito');
const { prefix, b58cencode, b58cdecode } = require('../packages/taquito-utils/dist/lib/taquito-utils');

const CLIENT_DB_PATH = path.join(__dirname, 'client-db');

const explorerApiUrl = {
  babylonnet: 'https://api.babylonnet.tzstats.com',
  mainnet: 'https://api.tzstats.com'
};

const rpcUrl = {
  babylonnet: 'https://rpcalpha.tzbeta.net/',
  mainnet: 'https://mainnet.tezrpc.me'
};

function ensureDirSync(dirpath) {
  try {
    fs.mkdirSync(dirpath, { recursive: true });
  } catch (err) {
    if (err.code !== 'EEXIST') throw err;
  }
}

function logOp(op) {
  /* When an operation is from a fresh address (i.e. that hasn't sent yet), it includes two results - 'reveal' and 'transaction'.
   *
   * Example as viewed in https://babylonnet.tzstats.com/opT57vGYVLssoFntRMzurUGCn6xUGkQKDYoVHTsZDkwpP4UdKwK :
   *
   * TransactionOperation {
      hash: 'opT57vGYVLssoFntRMzurUGCn6xUGkQKDYoVHTsZDkwpP4UdKwK',
      raw:
       { opbytes:
          '5b329629c3a6983b045522638fd96abef3de38b91f21d0b9b6c1a0e2c8539eb36b018bff89a463cfcbfb888609c533798bb02937b5be8c0bb0dd08e852ac0201038248829f1ed123b3f859df0ed8fbddf02bb2da9a2d5f303f366859587220f5266c018bff89a463cfcbfb888609c533798bb02937b5beec0ab1dd08c350ac02a08d06000192586940eed7475af41cb746060c57fc91fafda700af6e012721916bf43a217dd9a1990232976bf5ba050278fcf691a2ab28c631dc531e88f977978564cac5248598cc95fc7e30588cbb076df977dbf907d41fb922',
         opOb:
          { branch: 'BLQSrbq14i1PkEMRMvRp7yKYLuXUtH5yHd12pzJB6KAEFJj1vXc',
            contents: [Array],
            protocol: 'PsBabyM1eUXZseaJdmXFApDSBqj8YBfwELoxZHHW77EMcAbbwAS',
            signature:
             'spsig1Um9DuRxcVPSY6xQzng95ZhbS76XRZgG32xvzqypS5kbfJZh45ceKCNA5krtHgHgA41zyG4HEqedBGWweUjAWAQ5bV3m5y' },
         counter: 143023 },
      results:
       [ { kind: 'reveal',
           source: 'tz2M5Ui4xNtunJywkdpa5JYcX6LCZySbxJFR',
           fee: '1420',
           counter: '143024',
           gas_limit: '10600',
           storage_limit: '300',
           public_key: 'sppk7cEkwcib2wbKwpywZBVzcGsbtdFXohhAXMCSWhhRipxDbvdPsFQ',
           metadata: [Object] },
         { kind: 'transaction',
           source: 'tz2M5Ui4xNtunJywkdpa5JYcX6LCZySbxJFR',
           fee: '1388',
           counter: '143025',
           gas_limit: '10307',
           storage_limit: '300',
           amount: '100000',
           destination: 'tz2Mf3EFuVEyyz1osU6yc9XoBFnpZubWiSDP',
           metadata: [Object] } ],
      params:
       { kind: 'transaction',
         fee: 1388,
         gas_limit: 10307,
         storage_limit: 300,
         amount: '100000',
         destination: 'tz2Mf3EFuVEyyz1osU6yc9XoBFnpZubWiSDP' },
      source: 'tz2M5Ui4xNtunJywkdpa5JYcX6LCZySbxJFR' }
   */

  function sumFieldValues(fieldName) {
    return op.results.reduce((sum, currResult) => {
      return sum + parseInt(currResult[fieldName]);
    }, 0);
  }

  console.log(`hash = ${op.hash}`);
  console.log(`gas_limit = ${sumFieldValues('gas_limit')}`);
  console.log(`fee = ${Tezos.format('mutez', 'tz', sumFieldValues('fee'))} XTZ`);
  const transactionResult = op.results.find(res => res.kind === 'transaction');
  if (transactionResult) {
    console.log('--transaction--');
    console.log(`source = ${transactionResult.source}`);
    console.log(`amount = ${Tezos.format('mutez', 'tz', transactionResult.amount)} XTZ`);
    console.log(`destination = ${transactionResult.destination}`);
    console.log(`metadata = ${JSON.stringify(transactionResult.metadata)}`);
  } else {
    const delegateResult = op.results.find(res => res.kind === 'delegation');
    if (delegateResult) {
      console.log('--delegation--');
      console.log(`source = ${delegateResult.source}`);
      console.log(`delegate = ${delegateResult.delegate}`);
      console.log(`metadata = ${JSON.stringify(delegateResult.metadata)}`);
    }
  }
}

ensureDirSync(CLIENT_DB_PATH);
const adapter = new FileSync(path.join(CLIENT_DB_PATH, 'db.json'));
const db = low(adapter);
db.defaults({ addresses: [] }).write();

program
  .command('address')
  .option('-n, --network [name]', 'Name of network ("babylonnet" or "mainnet")')
  .action(async (options) => {
    const privateKeyHex = crypto.randomBytes(32).toString('hex');
    console.log('privateKeyHex =', privateKeyHex);
    const privateKey = b58cencode(privateKeyHex, prefix['spsk']);
    console.log('privateKey =', privateKey);
    Tezos.setProvider({
      signer: new InMemorySigner(privateKey),
      rpc: rpcUrl[options.network || 'babylonnet']
    });
    const address = await Tezos.signer.publicKeyHash();
    console.log(address);
    db.get('addresses').push({ address, privateKey }).write();
  });

program
  .command('balance <address>')
  .option('-n, --network [name]', 'Name of network ("babylonnet" or "mainnet")')
  .action(async (address, options) => {
    Tezos.setProvider({
      rpc: rpcUrl[options.network || 'babylonnet']
    });
    let balanceInMutez;
    try {
      balanceInMutez = await Tezos.tz.getBalance(address);
    } catch (err) {
      console.error('err =', err);
    }
    const balanceInXtz = Tezos.format('mutez', 'tz', balanceInMutez);
    console.log(`${balanceInXtz} XTZ`);
  });


program
  .command('transfer <from> <to> <xtz_amount>')
  .option('-n, --network [name]', 'Name of network ("babylonnet" or "mainnet")')
  .action(async (from, to, xtz_amount, options) => {
    const { privateKey } = db.get('addresses').find({address: from}).value();
    Tezos.setProvider({
      signer: new InMemorySigner(privateKey),
      rpc: rpcUrl[options.network || 'babylonnet']
    });
    try {
      console.log('#1');
      const forgedBytes = await Tezos.contract.getTransferSignatureHash({ to, amount: xtz_amount});
      console.log('forgedBytes =', JSON.stringify(forgedBytes, null, 2));
      const {prefixSig, sbytes} = await Tezos.signer.sign(forgedBytes.opbytes, new Uint8Array([3]));
      console.log('prefixSig =', prefixSig);
      console.log('sbytes =', sbytes);
      const op = await Tezos.contract.injectTransferSignatureAndBroadcast(forgedBytes, prefixSig, sbytes);
      logOp(op);

      const id = await op.confirmation();
      console.log('id =', id);
    } catch (err) {
      console.error('err =', err);
    }
  });

program
  .command('transfer-all <from> <to>')
  .alias('ta')
  .option('-n, --network [name]', 'Name of network ("babylonnet" or "mainnet")')
  .action(async (from, to, options) => {
    const network = options.network || 'babylonnet';
    const { privateKey } = db.get('addresses').find({address: from}).value();
    Tezos.setProvider({
      signer: new InMemorySigner(privateKey),
      rpc: rpcUrl[network]
    });
    try {
      // 1. get balance
      const balanceInMutez = await Tezos.tz.getBalance(from);
      console.log('balanceInMutez =', balanceInMutez.toString());

      // 2. mock with fake amount (in order to get the gas fee)
      const mockMutezAmount = balanceInMutez.div(2).decimalPlaces(0).toNumber();
      console.log('mockMutezAmount =', mockMutezAmount);
      const forgedBytes = await Tezos.contract.getTransferSignatureHash({ to, amount: mockMutezAmount, mutez: true });
      console.log('forgedBytes =', JSON.stringify(forgedBytes, null, 2));
      const totalFee = forgedBytes.opOb.contents.reduce((acc, currContent) => {
        return acc + parseInt(currContent.fee);
      }, 0);
      console.log('totalFee =', totalFee);

      // 3. calculate storage limit to burn (0 if destination is active)
      // const isDestinationActive = await isAddressActive(to, network);
      // const totalStorageLimit = isDestinationActive ?
      //   0 :
      //   forgedBytes.opOb.contents.reduce((acc, currContent) => {
      //     return acc + parseInt(currContent.storage_limit);
      //   }, 0);
      const totalStorageLimit = forgedBytes.opOb.contents.reduce((acc, currContent) => {
        return acc + parseInt(currContent.storage_limit);
      }, 0);
      console.log('totalStorageLimit =', totalStorageLimit);

      // 4. construct the new transaction with the entire balance minus the fees
      const mutezAmount = balanceInMutez.minus(totalFee + totalStorageLimit * 1000).toNumber();  // totalFee in mutez (1e-6), totalStorageLimit in millitez (1e-3)
      console.log('mutezAmount =', mutezAmount);
      const newForgedBytes = await Tezos.contract.getTransferSignatureHash({ to, amount: mutezAmount, mutez: true });
      console.log('newForgedBytes =', JSON.stringify(newForgedBytes, null, 2));

      // 5. sign
      const {prefixSig, sbytes} = await Tezos.signer.sign(newForgedBytes.opbytes, new Uint8Array([3]));
      console.log('prefixSig =', prefixSig);
      console.log('sbytes =', sbytes);
      const op = await Tezos.contract.injectTransferSignatureAndBroadcast(newForgedBytes, prefixSig, sbytes);
      logOp(op);

      const id = await op.confirmation();
      console.log('id =', id);
    } catch (err) {
      console.error('err =', err);
    }
  });

program
  .command('get-transfer-hash <from_x> <from_y> <to> <xtz_amount>')
  .alias('gth')
  .option('-n, --network [name]', 'Name of network ("babylonnet" or "mainnet")')
  .action(async (fromX, fromY, to, xtz_amount, options) => {
    const publicKey = {x: fromX, y: fromY};
    Tezos.setProvider({
      signer: new PublicOnlySigner(publicKey),
      rpc: rpcUrl[options.network || 'babylonnet']
    });
    try {
      console.log('#1');
      const forgedBytes = await Tezos.contract.getTransferSignatureHash({ to, amount: xtz_amount});
      console.log('forgedBytes =', JSON.stringify(forgedBytes, null, 2));
    } catch (err) {
      console.error('err =', err);
    }
  });

program
  .command('delegate <from> <to>')
  .description('Delegate funds to a baker account')
  .option('-n, --network [name]', 'Name of network ("babylonnet" or "mainnet")')
  .action(async (from, to, options) => {
    const { privateKey } = db.get('addresses').find({address: from}).value();
    Tezos.setProvider({
      signer: new InMemorySigner(privateKey),
      rpc: rpcUrl[options.network || 'babylonnet']
    });
    try {
      const forgedBytes = await Tezos.contract.getDelegateSignatureHash({source: from, delegate: to});
      console.log('forgedBytes =', forgedBytes);
      const {prefixSig, sbytes} = await Tezos.signer.sign(forgedBytes.opbytes, new Uint8Array([3]));
      console.log('prefixSig =', prefixSig);
      console.log('sbytes =', sbytes);
      const op = await Tezos.contract.injectDelegateSignatureAndBroadcast(forgedBytes, prefixSig, sbytes);
      logOp(op);

      const id = await op.confirmation();
      console.log('id =', id);
    } catch (err) {
      console.error('err =', err);
    }
  });

program
  .command('get-delegate-hash <from_x> <from_y> <to>')
  .description('Delegate funds to a baker account')
  .option('-n, --network [name]', 'Name of network ("babylonnet" or "mainnet")')
  .action(async (fromX, fromY, to, options) => {
    const publicKey = {x: fromX, y: fromY};
    Tezos.setProvider({
      signer: new PublicOnlySigner(publicKey),
      rpc: rpcUrl[options.network || 'babylonnet']
    });
    const forgedBytes = await Tezos.contract.getDelegateSignatureHash({source: from, delegate: to});
    console.log('forgedBytes =', forgedBytes);
  });

program
  .command('subscribe <address>')
  .description('Subscribe to get notifications regarding operations involving given address')
  .option('-n, --network [name]', 'Name of network ("babylonnet" or "mainnet")')
  .action(async (address, options) => {
    const rpc = rpcUrl[options.network || 'babylonnet'];
    console.log('rpc =', rpc);
    Tezos.setProvider({
      stream: rpc,
      rpc
    });
    try {
      const subscription = Tezos.stream.subscribeOperation([{or: [{source: address}, {destination: address}]}]);
      subscription.on('data', data => console.log('on("data") = ', data));
      subscription.on('error', error => console.error('on("error") = ', error));
    } catch (err) {
      console.error('err =', err);
    }
  });

program
  .command('validate <address>')
  .alias('v')
  .description('Validate given string is a valid Tezos address')
  .action(async (address) => {
    try {
      function logValid(isValid) {
        console.log(`${address} is ${isValid ? 'a valid' : 'an invalid'} Tezos address.`);
      }

      let pref = address.substring(0, 3);
      if (!['tz1', 'tz2', 'tz3'].includes(pref)) {
        pref = address.substring(0, 2);
        if (pref !== 'KT') {
          return logValid(false);
        }
      }

      b58cdecode(address, prefix[pref]);
      logValid(true);
    } catch (err) {
      logValid(false);
    }
  });

program
  .command('is-active <address>')
  .alias('ia')
  .description('is given Tezos address active')
  .option('-n, --network [name]', 'Name of network ("babylonnet" or "mainnet")')
  .action(async (address, options) => {
    const network = options.network || 'babylonnet';
    Tezos.setProvider({
      rpc: rpcUrl[network]
    });
    try {
      console.log(await isAddressActive(address, network));
    } catch (e) {
      console.error(e);
    }
  });

async function isAddressActive(address, network) {
  try {
    const response = await rp({
      method: 'GET',
      uri: `${explorerApiUrl[network]}/explorer/account/${address}/op`,
      json: true
    });

    return !!response.first_seen;
  } catch (e) {
    return false;
  }
}

program.parse(process.argv);
